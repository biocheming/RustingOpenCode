use clap::Parser;

mod agent_cmd;
mod auth;
mod cli;
mod db;
mod debug;
mod generate;
mod github;
mod import_export;
mod mcp_cmd;
mod providers;
mod remote;
mod run;
mod server;
mod session_cmd;
mod tui;
mod upgrade;
mod util;

use agent_cmd::handle_agent_command;
use auth::handle_auth_command;
use cli::*;
use db::{handle_db_command, handle_stats_command};
use debug::handle_debug_command;
use generate::{handle_generate_command, list_models};
use github::{handle_github_command, handle_pr_command};
use import_export::{export_session_data, import_session_data};
use mcp_cmd::handle_mcp_command;
use run::run_non_interactive;
use server::{run_acp_command, run_server_command, run_web_command};
use session_cmd::{handle_session_command, show_config};
use tui::run_tui;
use upgrade::{handle_uninstall_command, handle_upgrade_command};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // Write logs to a file so they're visible even when TUI captures stderr.
    let log_dir = dirs::data_local_dir()
        .unwrap_or_else(|| std::path::PathBuf::from("/tmp"))
        .join("rocode")
        .join("log");
    std::fs::create_dir_all(&log_dir).ok();
    let log_file = std::fs::File::create(log_dir.join("rocode.log")).ok();
    if let Some(file) = log_file {
        use tracing_subscriber::EnvFilter;
        let filter = EnvFilter::try_from_default_env()
            .unwrap_or_else(|_| EnvFilter::new("info"));
        tracing_subscriber::fmt()
            .with_env_filter(filter)
            .with_writer(std::sync::Mutex::new(file))
            .with_ansi(false)
            .init();
    } else {
        tracing_subscriber::fmt::init();
    }

    let cli = Cli::parse();

    match cli.command {
        Some(Commands::Tui {
            project,
            model,
            continue_last,
            session,
            fork,
            prompt,
            agent,
            port,
            hostname,
            mdns,
            mdns_domain,
            cors,
        }) => {
            run_tui(
                project,
                model,
                continue_last,
                session,
                fork,
                agent,
                prompt,
                port,
                hostname,
                mdns,
                mdns_domain,
                cors,
                None,
                None,
            )
            .await?;
        }
        Some(Commands::Attach {
            url,
            dir,
            session,
            password,
        }) => {
            run_tui(
                dir,
                None,
                false,
                session,
                false,
                "build".to_string(),
                None,
                0,
                "127.0.0.1".to_string(),
                false,
                "rocode.local".to_string(),
                vec![],
                Some(url),
                password,
            )
            .await?;
        }
        Some(Commands::Run {
            message,
            command,
            continue_last,
            session,
            fork,
            share,
            model,
            agent,
            file,
            format,
            title,
            attach,
            dir,
            port,
            variant,
            thinking,
        }) => {
            run_non_interactive(
                message,
                command,
                continue_last,
                session,
                fork,
                share,
                model,
                agent,
                file,
                format,
                title,
                attach,
                dir,
                port,
                variant,
                thinking,
            )
            .await?;
        }
        Some(Commands::Serve {
            port,
            hostname,
            mdns,
            mdns_domain,
            cors,
        }) => {
            run_server_command("serve", port, hostname, mdns, mdns_domain, cors).await?;
        }
        Some(Commands::Web {
            port,
            hostname,
            mdns,
            mdns_domain,
            cors,
        }) => {
            run_web_command(port, hostname, mdns, mdns_domain, cors).await?;
        }
        Some(Commands::Acp {
            port,
            hostname,
            mdns,
            mdns_domain,
            cors,
            cwd,
        }) => {
            run_acp_command(port, hostname, mdns, mdns_domain, cors, cwd).await?;
        }
        Some(Commands::Models {
            provider,
            refresh,
            verbose,
        }) => {
            list_models(provider, refresh, verbose).await?;
        }
        Some(Commands::Session { action }) => {
            handle_session_command(action).await?;
        }
        Some(Commands::Stats {
            days,
            tools,
            models,
            project,
        }) => {
            handle_stats_command(days, tools, models, project).await?;
        }
        Some(Commands::Db {
            action,
            query,
            format,
        }) => {
            handle_db_command(action, query, format).await?;
        }
        Some(Commands::Config) => {
            show_config().await?;
        }
        Some(Commands::Auth { action }) => {
            handle_auth_command(action).await?;
        }
        Some(Commands::Agent { action }) => {
            handle_agent_command(action).await?;
        }
        Some(Commands::Debug { action }) => {
            handle_debug_command(action).await?;
        }
        Some(Commands::Mcp { server, action }) => {
            handle_mcp_command(server, action).await?;
        }
        Some(Commands::Export { session_id, output }) => {
            export_session_data(session_id, output).await?;
        }
        Some(Commands::Import { file }) => {
            import_session_data(file).await?;
        }
        Some(Commands::Github { action }) => {
            handle_github_command(action).await?;
        }
        Some(Commands::Pr { number }) => {
            handle_pr_command(number).await?;
        }
        Some(Commands::Upgrade { target, method }) => {
            handle_upgrade_command(target, method).await?;
        }
        Some(Commands::Uninstall {
            keep_config,
            keep_data,
            dry_run,
            force,
        }) => {
            handle_uninstall_command(keep_config, keep_data, dry_run, force).await?;
        }
        Some(Commands::Generate) => {
            handle_generate_command().await?;
        }
        Some(Commands::Version) => {
            println!("OpenCode {}", env!("CARGO_PKG_VERSION"));
        }
        None => {
            run_tui(
                None,
                None,
                false,
                None,
                false,
                "build".to_string(),
                None,
                0,
                "127.0.0.1".to_string(),
                false,
                "rocode.local".to_string(),
                vec![],
                None,
                None,
            )
            .await?;
        }
    }

    Ok(())
}
